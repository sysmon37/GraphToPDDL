<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.input_RO API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.input_RO</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from operator import itemgetter


def read_JSON(path):
    &#34;&#34;&#34;
    Reads a JSON file and returns its content.

    Args:
        path (str): Path to the file.

    Returns:
        json: JSON object
    &#34;&#34;&#34;
    with open(path) as file:
        obj = json.load(file)
        file.close()
    return obj


def update_graph_with_ROs(graph, ros):
    &#34;&#34;&#34;
    Excutes the operations (replace, delete, add) of every revision operators.
    Args:
        graph (networkx graph): The graph.
        ros (list): List of JSON like object.
    &#34;&#34;&#34;
    for ro in ros:
        id, trigger, operations = itemgetter(&#34;id&#34;, &#34;trigger&#34;, &#34;operations&#34;)(ro)
        operations = ro[&#34;operations&#34;]
        for op in operations:
            type = op[&#34;type&#34;]
            if type == &#34;replace&#34;:
                replace_operation(graph, id, trigger, op)
            elif type == &#34;delete&#34;:
                delete_operation(graph, op)
            else:
                add_operation(graph, id, trigger, op)


def add_all_new_nodes(graph, id_ro, trigger, operation):
    &#34;&#34;&#34;
    Add a list of new nodes with some attributes. These nodes do not have any edges after the execution of this function.

    Use &#39;add_all_new_edges&#39; to add the respectives edges.

    Args:
        graph (networkx graph): The graph.
        id_ro (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (object): The operation object.
    &#34;&#34;&#34;
    edge_to_successors = []
    for node in operation[&#34;newNodes&#34;]:
        # taking node id and the rest of its attributes
        node_copy = {**node}
        new_node_id = node_copy[&#34;id&#34;]
        node_type = node_copy[&#34;type&#34;]

        # if the current node needs to connect to the successors of the &#39;existing node&#39;
        if node_copy.get(&#34;edgeToSuccessors&#34;, False):
            edge_to_successors.append(
                {&#34;node&#34;: new_node_id, **node_copy.get(&#34;edgeToSuccessorsAttr&#34;, {})}
            )

        if node_type == &#34;action&#34;:
            node_copy[&#34;is_original&#34;] = False

        node_copy.pop(&#34;id&#34;, None)
        node_copy.pop(&#34;type&#34;, None)
        node_copy.pop(&#34;predecessors&#34;, None)
        node_copy.pop(&#34;edgeToSuccessors&#34;, None)

        # adding it to the graph
        # Currently assuming the added nodes are all actionNode
        graph.add_node(
            new_node_id, type=node_type, idRO=id_ro, trigger=trigger, **node_copy
        )
    return edge_to_successors


def add_all_new_edges(graph, operation, edge_to_successors):
    &#34;&#34;&#34;
    Add all the edges from the operation object.

    Nodes related to these edges must be added to the graph prior to this function call.

    Use &#39;add_all_new_nodes&#39; to add the respectives nodes before calling this function.


    Args:
        graph (networkx graph): The graph.
        id_ro (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (object): The operation object.
    &#34;&#34;&#34;
    existing_node = operation[&#34;existingNode&#34;]

    for node in operation[&#34;newNodes&#34;]:
        node_copy = {**node}
        new_node_id = node_copy[&#34;id&#34;]

        predecessor_list = node_copy.get(
            &#34;predecessors&#34;, list(graph.predecessors(existing_node))
        )

        for pred in predecessor_list:
            if isinstance(pred, str):
                pred = {&#34;nodeId&#34;: pred}
            pred_node = pred[&#34;nodeId&#34;]
            pred.pop(&#34;nodeId&#34;, None)
            # copying the edge data if any but only to the first new node
            edge_data = graph.get_edge_data(pred_node, existing_node)
            edge_data = edge_data[0] if edge_data else {}
            if not graph.has_edge(pred_node, new_node_id):
                graph.add_edge(pred_node, new_node_id, **pred, **edge_data)

            current_existing_nodes_successors = list(graph.successors(existing_node))

    for edge in edge_to_successors:
        node = edge[&#34;node&#34;]
        edge.pop(&#34;node&#34;, None)
        for succ in current_existing_nodes_successors:
            if not graph.has_edge(node, succ):
                # need one last edge from the last added node to the same node &#39;Existing_node&#39; is pointing too
                graph.add_edge(node, succ, **edge)


def replace_operation(graph, id_ro, trigger, operation):
    &#34;&#34;&#34;
    Replace operation inserts a sequence of new nodes.

    This function is a 2-steps process. First, we add all the nodes to be added. Secondly, we add all the edges.

    This allows the RO file to have the nodes in any particular order.

    Args:
        graph (networkx graph): The graph.
        id_ro (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (object): The operation object
    &#34;&#34;&#34;
    edge_to_successors = add_all_new_nodes(graph, id_ro, trigger, operation)
    add_all_new_edges(graph, operation, edge_to_successors)


def delete_operation(graph, operation):
    &#34;&#34;&#34;
    Deletes a node. Links its predecessors and successors together.

    Args:
        graph (networkx graph): The graph.
        operation (str): The operation object
    &#34;&#34;&#34;
    node_to_delete = operation[&#34;existingNode&#34;]
    predecessors = graph.predecessors(node_to_delete)
    successors = graph.successors(node_to_delete)

    for pred in predecessors:
        for succ in successors:
            pred_edge_data = graph.get_edge_data(pred, node_to_delete)[0]
            succ_edge_data = graph.get_edge_data(node_to_delete, succ)[0]

            if not graph.has_edge(pred, succ):
                graph.add_edge(pred, succ, **pred_edge_data, **succ_edge_data)


def add_operation(graph, idRO, trigger, operation):
    &#34;&#34;&#34;
    Add operation inserts a node(s) between a list of predeccessors and successors.

    Args:
        graph (networkx graph): The graph.
        idRO (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (str): The operation object
    &#34;&#34;&#34;

    addedNodes = operation[&#34;newNodes&#34;]

    # for predecessor in predecessors:
    #     for successor in successors:
    for node in addedNodes:
        # taking node id and the rest of its attributes
        node_copy = {**node} # cost ...
        new_node_id = node_copy[&#34;id&#34;]

        node_type = node_copy[&#34;type&#34;]
        del node_copy[&#34;id&#34;]
        del node_copy[&#34;type&#34;]
        
        # Predecessors and successors are lists of dictionaries
        predecessors_list = node_copy.get(&#34;predecessors&#34;, None)
        successors_list = node_copy.get(&#34;successors&#34;, None)
        node_copy.pop(&#34;predecessors&#34;, None)
        node_copy.pop(&#34;successors&#34;, None)

        # disease/goal case
        if not predecessors_list:
            # print(&#34;No predecessors&#34;)
            predecessors_list = [&#34;disease&#34;]
        if not successors_list:
            # print(&#34;No successors&#34;)
            successors_list = [&#34;goal&#34;]

        for predecessor in predecessors_list:
            for successor in successors_list:
                # adding it to the graph
                # Currently assuming the added nodes are all actionNode

                graph.add_node(
                    new_node_id,
                    type=node_type,
                    is_original=False,
                    idRO=idRO,
                    trigger=trigger,
                    **node_copy
                )

                # Get nodeId of predecessor and successor
                if not predecessor == &#34;disease&#34;:
                    pred = {**predecessor}
                    predecessor_node = pred.get(&#34;nodeId&#34;, None)
                    pred.pop(&#34;nodeId&#34;, None)
                if not successor == &#34;goal&#34;:
                    succ = {**successor}
                    successor_node = succ.get(&#34;nodeId&#34;, None)
                    succ.pop(&#34;nodeId&#34;, None)

                # Get range of predecessor and successor
                if not predecessor == &#34;disease&#34;:
                    predecessor_range = pred.get(&#34;range&#34;, None)
                    pred.pop(&#34;range&#34;, None)
                if not successor == &#34;goal&#34;:
                    successor_range = succ.get(&#34;range&#34;, None)
                    succ.pop(&#34;range&#34;, None)
                
                # Case where the Predecessor node and successor node are adjecent
                # if graph.has_edge(predecessor_node, successor_node) :
                # Adding the edge between the new node and the predecessor with the edge data
                # We only want one edge between the predecessor and the new node
                if not graph.has_edge(predecessor_node, new_node_id):
                    if not predecessor == &#34;disease&#34;:

                        if graph.has_edge(predecessor_node, successor_node) and not predecessor_range : # if the range is not specified from the predecessor
                            graph.add_edge(
                                predecessor_node,
                                new_node_id,
                                **graph.get_edge_data(predecessor_node, successor_node)[0]
                            )
                        else:
                            graph.add_edge(
                                predecessor_node,
                                new_node_id,
                                range=predecessor_range,
                                **pred
                            )
                
                # else:
               
                #     graph.add_edge(
                #         predecessor_node,
                #         new_node_id,
                #         range=predecessor_range,
                #         **pred
                #     )

                    # UPDATE: We keep the edge between the predecessor and the successor
                    # We need to remove the edges between the predecessor and the successor
                    # graph.remove_edge(predecessor, successor) 

                # Case where the predecessor node is not adjacent to the successor node
                # else: # Probably not needed since we will not add a &#34;new edge&#34;, Will need to test with a bigger problem
                #     tmpSuccessors = list(graph.successors(predecessor_node))

                #     for tmpSuccessor in tmpSuccessors:
                #         # What range data do we want to copy/overlap?
                #         # Using the first edge data for now
                #         if graph.get_edge_data(predecessor_node, tmpSuccessor):
                #             if not successor == &#34;disease&#34;:
                #                 # print(new_node_id)
                #                 tmpData = graph.get_edge_data(predecessor_node, tmpSuccessor)[0]
                #                 # We only want one edge between the predecessor and the new node
                #                 if not graph.has_edge(predecessor_node, new_node_id):
                #                     graph.add_edge(predecessor_node, new_node_id, **tmpData)

                # We only want one edge between the new node and the successor
                if not graph.has_edge(new_node_id, successor_node):
                    if not successor == &#34;goal&#34;:
                        if node_type == &#34;decision&#34;:
                        #     for ranges in node_range:
                        #         if ranges.get(&#34;successors&#34;, None) == successor_node:
                            graph.add_edge(new_node_id, successor_node,range=successor_range,**succ)
                        else:
                            graph.add_edge(new_node_id, successor_node,**succ)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.input_RO.add_all_new_edges"><code class="name flex">
<span>def <span class="ident">add_all_new_edges</span></span>(<span>graph, operation, edge_to_successors)</span>
</code></dt>
<dd>
<div class="desc"><p>Add all the edges from the operation object.</p>
<p>Nodes related to these edges must be added to the graph prior to this function call.</p>
<p>Use 'add_all_new_nodes' to add the respectives nodes before calling this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>The graph.</dd>
<dt><strong><code>id_ro</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the revision operator.</dd>
<dt><strong><code>trigger</code></strong> :&ensp;<code>list</code></dt>
<dd>List of triggering nodes.</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>object</code></dt>
<dd>The operation object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_all_new_edges(graph, operation, edge_to_successors):
    &#34;&#34;&#34;
    Add all the edges from the operation object.

    Nodes related to these edges must be added to the graph prior to this function call.

    Use &#39;add_all_new_nodes&#39; to add the respectives nodes before calling this function.


    Args:
        graph (networkx graph): The graph.
        id_ro (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (object): The operation object.
    &#34;&#34;&#34;
    existing_node = operation[&#34;existingNode&#34;]

    for node in operation[&#34;newNodes&#34;]:
        node_copy = {**node}
        new_node_id = node_copy[&#34;id&#34;]

        predecessor_list = node_copy.get(
            &#34;predecessors&#34;, list(graph.predecessors(existing_node))
        )

        for pred in predecessor_list:
            if isinstance(pred, str):
                pred = {&#34;nodeId&#34;: pred}
            pred_node = pred[&#34;nodeId&#34;]
            pred.pop(&#34;nodeId&#34;, None)
            # copying the edge data if any but only to the first new node
            edge_data = graph.get_edge_data(pred_node, existing_node)
            edge_data = edge_data[0] if edge_data else {}
            if not graph.has_edge(pred_node, new_node_id):
                graph.add_edge(pred_node, new_node_id, **pred, **edge_data)

            current_existing_nodes_successors = list(graph.successors(existing_node))

    for edge in edge_to_successors:
        node = edge[&#34;node&#34;]
        edge.pop(&#34;node&#34;, None)
        for succ in current_existing_nodes_successors:
            if not graph.has_edge(node, succ):
                # need one last edge from the last added node to the same node &#39;Existing_node&#39; is pointing too
                graph.add_edge(node, succ, **edge)</code></pre>
</details>
</dd>
<dt id="src.input_RO.add_all_new_nodes"><code class="name flex">
<span>def <span class="ident">add_all_new_nodes</span></span>(<span>graph, id_ro, trigger, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a list of new nodes with some attributes. These nodes do not have any edges after the execution of this function.</p>
<p>Use 'add_all_new_edges' to add the respectives edges.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>The graph.</dd>
<dt><strong><code>id_ro</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the revision operator.</dd>
<dt><strong><code>trigger</code></strong> :&ensp;<code>list</code></dt>
<dd>List of triggering nodes.</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>object</code></dt>
<dd>The operation object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_all_new_nodes(graph, id_ro, trigger, operation):
    &#34;&#34;&#34;
    Add a list of new nodes with some attributes. These nodes do not have any edges after the execution of this function.

    Use &#39;add_all_new_edges&#39; to add the respectives edges.

    Args:
        graph (networkx graph): The graph.
        id_ro (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (object): The operation object.
    &#34;&#34;&#34;
    edge_to_successors = []
    for node in operation[&#34;newNodes&#34;]:
        # taking node id and the rest of its attributes
        node_copy = {**node}
        new_node_id = node_copy[&#34;id&#34;]
        node_type = node_copy[&#34;type&#34;]

        # if the current node needs to connect to the successors of the &#39;existing node&#39;
        if node_copy.get(&#34;edgeToSuccessors&#34;, False):
            edge_to_successors.append(
                {&#34;node&#34;: new_node_id, **node_copy.get(&#34;edgeToSuccessorsAttr&#34;, {})}
            )

        if node_type == &#34;action&#34;:
            node_copy[&#34;is_original&#34;] = False

        node_copy.pop(&#34;id&#34;, None)
        node_copy.pop(&#34;type&#34;, None)
        node_copy.pop(&#34;predecessors&#34;, None)
        node_copy.pop(&#34;edgeToSuccessors&#34;, None)

        # adding it to the graph
        # Currently assuming the added nodes are all actionNode
        graph.add_node(
            new_node_id, type=node_type, idRO=id_ro, trigger=trigger, **node_copy
        )
    return edge_to_successors</code></pre>
</details>
</dd>
<dt id="src.input_RO.add_operation"><code class="name flex">
<span>def <span class="ident">add_operation</span></span>(<span>graph, idRO, trigger, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Add operation inserts a node(s) between a list of predeccessors and successors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>The graph.</dd>
<dt><strong><code>idRO</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the revision operator.</dd>
<dt><strong><code>trigger</code></strong> :&ensp;<code>list</code></dt>
<dd>List of triggering nodes.</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>str</code></dt>
<dd>The operation object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_operation(graph, idRO, trigger, operation):
    &#34;&#34;&#34;
    Add operation inserts a node(s) between a list of predeccessors and successors.

    Args:
        graph (networkx graph): The graph.
        idRO (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (str): The operation object
    &#34;&#34;&#34;

    addedNodes = operation[&#34;newNodes&#34;]

    # for predecessor in predecessors:
    #     for successor in successors:
    for node in addedNodes:
        # taking node id and the rest of its attributes
        node_copy = {**node} # cost ...
        new_node_id = node_copy[&#34;id&#34;]

        node_type = node_copy[&#34;type&#34;]
        del node_copy[&#34;id&#34;]
        del node_copy[&#34;type&#34;]
        
        # Predecessors and successors are lists of dictionaries
        predecessors_list = node_copy.get(&#34;predecessors&#34;, None)
        successors_list = node_copy.get(&#34;successors&#34;, None)
        node_copy.pop(&#34;predecessors&#34;, None)
        node_copy.pop(&#34;successors&#34;, None)

        # disease/goal case
        if not predecessors_list:
            # print(&#34;No predecessors&#34;)
            predecessors_list = [&#34;disease&#34;]
        if not successors_list:
            # print(&#34;No successors&#34;)
            successors_list = [&#34;goal&#34;]

        for predecessor in predecessors_list:
            for successor in successors_list:
                # adding it to the graph
                # Currently assuming the added nodes are all actionNode

                graph.add_node(
                    new_node_id,
                    type=node_type,
                    is_original=False,
                    idRO=idRO,
                    trigger=trigger,
                    **node_copy
                )

                # Get nodeId of predecessor and successor
                if not predecessor == &#34;disease&#34;:
                    pred = {**predecessor}
                    predecessor_node = pred.get(&#34;nodeId&#34;, None)
                    pred.pop(&#34;nodeId&#34;, None)
                if not successor == &#34;goal&#34;:
                    succ = {**successor}
                    successor_node = succ.get(&#34;nodeId&#34;, None)
                    succ.pop(&#34;nodeId&#34;, None)

                # Get range of predecessor and successor
                if not predecessor == &#34;disease&#34;:
                    predecessor_range = pred.get(&#34;range&#34;, None)
                    pred.pop(&#34;range&#34;, None)
                if not successor == &#34;goal&#34;:
                    successor_range = succ.get(&#34;range&#34;, None)
                    succ.pop(&#34;range&#34;, None)
                
                # Case where the Predecessor node and successor node are adjecent
                # if graph.has_edge(predecessor_node, successor_node) :
                # Adding the edge between the new node and the predecessor with the edge data
                # We only want one edge between the predecessor and the new node
                if not graph.has_edge(predecessor_node, new_node_id):
                    if not predecessor == &#34;disease&#34;:

                        if graph.has_edge(predecessor_node, successor_node) and not predecessor_range : # if the range is not specified from the predecessor
                            graph.add_edge(
                                predecessor_node,
                                new_node_id,
                                **graph.get_edge_data(predecessor_node, successor_node)[0]
                            )
                        else:
                            graph.add_edge(
                                predecessor_node,
                                new_node_id,
                                range=predecessor_range,
                                **pred
                            )
                
                # else:
               
                #     graph.add_edge(
                #         predecessor_node,
                #         new_node_id,
                #         range=predecessor_range,
                #         **pred
                #     )

                    # UPDATE: We keep the edge between the predecessor and the successor
                    # We need to remove the edges between the predecessor and the successor
                    # graph.remove_edge(predecessor, successor) 

                # Case where the predecessor node is not adjacent to the successor node
                # else: # Probably not needed since we will not add a &#34;new edge&#34;, Will need to test with a bigger problem
                #     tmpSuccessors = list(graph.successors(predecessor_node))

                #     for tmpSuccessor in tmpSuccessors:
                #         # What range data do we want to copy/overlap?
                #         # Using the first edge data for now
                #         if graph.get_edge_data(predecessor_node, tmpSuccessor):
                #             if not successor == &#34;disease&#34;:
                #                 # print(new_node_id)
                #                 tmpData = graph.get_edge_data(predecessor_node, tmpSuccessor)[0]
                #                 # We only want one edge between the predecessor and the new node
                #                 if not graph.has_edge(predecessor_node, new_node_id):
                #                     graph.add_edge(predecessor_node, new_node_id, **tmpData)

                # We only want one edge between the new node and the successor
                if not graph.has_edge(new_node_id, successor_node):
                    if not successor == &#34;goal&#34;:
                        if node_type == &#34;decision&#34;:
                        #     for ranges in node_range:
                        #         if ranges.get(&#34;successors&#34;, None) == successor_node:
                            graph.add_edge(new_node_id, successor_node,range=successor_range,**succ)
                        else:
                            graph.add_edge(new_node_id, successor_node,**succ)</code></pre>
</details>
</dd>
<dt id="src.input_RO.delete_operation"><code class="name flex">
<span>def <span class="ident">delete_operation</span></span>(<span>graph, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a node. Links its predecessors and successors together.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>The graph.</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>str</code></dt>
<dd>The operation object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_operation(graph, operation):
    &#34;&#34;&#34;
    Deletes a node. Links its predecessors and successors together.

    Args:
        graph (networkx graph): The graph.
        operation (str): The operation object
    &#34;&#34;&#34;
    node_to_delete = operation[&#34;existingNode&#34;]
    predecessors = graph.predecessors(node_to_delete)
    successors = graph.successors(node_to_delete)

    for pred in predecessors:
        for succ in successors:
            pred_edge_data = graph.get_edge_data(pred, node_to_delete)[0]
            succ_edge_data = graph.get_edge_data(node_to_delete, succ)[0]

            if not graph.has_edge(pred, succ):
                graph.add_edge(pred, succ, **pred_edge_data, **succ_edge_data)</code></pre>
</details>
</dd>
<dt id="src.input_RO.read_JSON"><code class="name flex">
<span>def <span class="ident">read_JSON</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a JSON file and returns its content.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>json</code></dt>
<dd>JSON object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_JSON(path):
    &#34;&#34;&#34;
    Reads a JSON file and returns its content.

    Args:
        path (str): Path to the file.

    Returns:
        json: JSON object
    &#34;&#34;&#34;
    with open(path) as file:
        obj = json.load(file)
        file.close()
    return obj</code></pre>
</details>
</dd>
<dt id="src.input_RO.replace_operation"><code class="name flex">
<span>def <span class="ident">replace_operation</span></span>(<span>graph, id_ro, trigger, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace operation inserts a sequence of new nodes.</p>
<p>This function is a 2-steps process. First, we add all the nodes to be added. Secondly, we add all the edges.</p>
<p>This allows the RO file to have the nodes in any particular order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>The graph.</dd>
<dt><strong><code>id_ro</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the revision operator.</dd>
<dt><strong><code>trigger</code></strong> :&ensp;<code>list</code></dt>
<dd>List of triggering nodes.</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>object</code></dt>
<dd>The operation object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_operation(graph, id_ro, trigger, operation):
    &#34;&#34;&#34;
    Replace operation inserts a sequence of new nodes.

    This function is a 2-steps process. First, we add all the nodes to be added. Secondly, we add all the edges.

    This allows the RO file to have the nodes in any particular order.

    Args:
        graph (networkx graph): The graph.
        id_ro (str): The ID of the revision operator.
        trigger (list): List of triggering nodes.
        operation (object): The operation object
    &#34;&#34;&#34;
    edge_to_successors = add_all_new_nodes(graph, id_ro, trigger, operation)
    add_all_new_edges(graph, operation, edge_to_successors)</code></pre>
</details>
</dd>
<dt id="src.input_RO.update_graph_with_ROs"><code class="name flex">
<span>def <span class="ident">update_graph_with_ROs</span></span>(<span>graph, ros)</span>
</code></dt>
<dd>
<div class="desc"><p>Excutes the operations (replace, delete, add) of every revision operators.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>The graph.</dd>
<dt><strong><code>ros</code></strong> :&ensp;<code>list</code></dt>
<dd>List of JSON like object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_graph_with_ROs(graph, ros):
    &#34;&#34;&#34;
    Excutes the operations (replace, delete, add) of every revision operators.
    Args:
        graph (networkx graph): The graph.
        ros (list): List of JSON like object.
    &#34;&#34;&#34;
    for ro in ros:
        id, trigger, operations = itemgetter(&#34;id&#34;, &#34;trigger&#34;, &#34;operations&#34;)(ro)
        operations = ro[&#34;operations&#34;]
        for op in operations:
            type = op[&#34;type&#34;]
            if type == &#34;replace&#34;:
                replace_operation(graph, id, trigger, op)
            elif type == &#34;delete&#34;:
                delete_operation(graph, op)
            else:
                add_operation(graph, id, trigger, op)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.input_RO.add_all_new_edges" href="#src.input_RO.add_all_new_edges">add_all_new_edges</a></code></li>
<li><code><a title="src.input_RO.add_all_new_nodes" href="#src.input_RO.add_all_new_nodes">add_all_new_nodes</a></code></li>
<li><code><a title="src.input_RO.add_operation" href="#src.input_RO.add_operation">add_operation</a></code></li>
<li><code><a title="src.input_RO.delete_operation" href="#src.input_RO.delete_operation">delete_operation</a></code></li>
<li><code><a title="src.input_RO.read_JSON" href="#src.input_RO.read_JSON">read_JSON</a></code></li>
<li><code><a title="src.input_RO.replace_operation" href="#src.input_RO.replace_operation">replace_operation</a></code></li>
<li><code><a title="src.input_RO.update_graph_with_ROs" href="#src.input_RO.update_graph_with_ROs">update_graph_with_ROs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>