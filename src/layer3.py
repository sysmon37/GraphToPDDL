import argparse as ap
import traceback
import networkx as nwx
import matplotlib.pyplot as plt
import re


#This procedurre requires a dot file representing a graph to be specified as an
#argument when running the python script (see command to run below). Specifically,
#the dot file must represent the union of all actionable graphs (AGs) in a
#multimorbidity case. In addition the code below needs to access two internal
#treatment plans to be compared. These must be stored in the Plans/ folder and
#named baseplan.txt and optplan.txt.
#
#To run a simple test case:
#   python3.8 toPDDL.py UseCases/Dot_files/testcase-simple.dot
#   --no-ro --p-name problem1 --d-name domain1


def processLayer3(graphUAG, base_path, opt_path):
    """
    This function addresses "layer 3" explainability. Layer 3 explanations are
    about explaining an objective function. Specifically, differences between a
    treatment plan that is optimal accordiing to the objective function and a
    baseline plan are identified. This is done by comparing the two graphs
    corresponding to the two plans. The internal treatment plans to be compared
    are stored in folder Plans.

    Input Args:
        graphUAG (networkx graph): the union of all actionable graphs (AGs) in a
        multimorbidity case
        base_path: path to a file with the base plan
        opt_path: path to a file with the opt plan 

    Output:
        none

    """

    #gbase_diff is a graph consisting of only those nodes that are present in the
    #base plan but not in the optimal plan

    #gopt_diff is a graph consisting of only those nodes that are present in the
    #optimal plan but not in the base plan

    #Get the differences, gbase_diff and gopt_diff. For now these are not returned
    # -- this will depend on how the function is integrated into the pipeline.
    gbase_diff, gopt_diff = process(graphUAG, base_path, opt_path)



def process(graphUAG, base_path, opt_path):
    """
    This function carries out the following steps:

    1. Read in the treatment plans, get the nodes visited in each plan, construct
       the (sub)graphs, G_base and G_opt, representing the two plans.
    2. Find the maximum common subgraph G_same, common to G_base and G_opt. This
       includes all nodes in common, and thus the subgraph may not be connected.
    3. Delete G_same from G_base and G_opt. This yields the differences between
       G_base and G_opt.

    Input Args:
        graphUAG (networkx graph): the union of all actionable graphs (AGs) in a
        multimorbidity case
        base_path: path to a file with the base plan
        opt_path: path to a file with the opt plan 


    Output:
        gbase_diff: graph consisting of only those nodes in graph_G_base that are
        not present in graph_G_opt

        gopt_diff: graph consisting of only those nodes in graph_G_opt that are
        not present in graph_G_base

    """


    print("Printing graph: ")
    print(graphUAG.nodes)
    print(graphUAG.edges)

    #Get G_base
    graph_G_base = get_treatment_graph(graphUAG, base_path)
    #Get G_opt
    graph_G_opt = get_treatment_graph(graphUAG, opt_path)

    #Find the max common subgraph (all the nodes common to both graphs) G_same
    graph_G_same = find_max_common_subgraph(graph_G_base, graph_G_opt)

    #Delete G_same from G_base and from G_opt to find the differences between the
    #two.
    gbase_diff, gopt_diff = find_differences(graph_G_base, graph_G_opt, graph_G_same)

    return gbase_diff, gopt_diff



def get_treatment_graph(unionAG, plan_path):
    """
    This function extracts the list of clinical nodes visited in the internal
    treatment plan generated by the planner. It does so for the base plan ('base')
    and for the optimal plan ('opt'). We assume that these are the two plans being
    compared. The function returns the subgraph of unionAG induced by the clinical
    nodes pertaining to the treatment plan.

    Input Args:
        unionAG (networkx graph): the union of all actionable graphs (AGs) in a
        multimorbidity case

        plan_path: a path to the plan file (base or opt)

    Output:
        Subgraph of unionAG consisting of only those clinical nodes in the base
        plan or in the optimal plan, as specified by which_plan. For any other
        value of which_plan, nothing is returned.

    """

    node_list = parseTreatmentPlan(plan_path)
    return nwx.subgraph(unionAG, node_list)


def parseTreatmentPlan(plan_path):
    """
    This function uses regular expressions to parse the treatment plan specified
    by which_plan. It identifies and creates a list of the clinical action and
    decision nodes in the plan. It returns this list of nodes.

    Input Args:
        plan_path: a path to the plan file (base or opt)

    Output:
        List of clinical action and decision nodes in the plan specified by
        which_plan.

    """

    nodelist = []
    
    plan_output = open(plan_path, 'r')

    #with open('plan.txt', 'r') as plan_output:
    for text in plan_output:
        #print(text)

        match1 = re.search(r'make', text)
        match2 = re.search(r'decision', text)
        match3 = re.search(r'take', text)
        match4 = re.search(r'action', text)
        match5 = re.search(r'finalgoalreached', text)

        if (match1 and match2) or (match3 and match4):
            print('Matched')
            l = text.split()
            nodelist.append(l[3])
        else:
            if match5:
                print('Goal')
                l = text.split()
                nodelist.append(l[3])

    print('Parse: printing nodelist:')
    print(nodelist)

    return nodelist


def find_max_common_subgraph(gbase, gopt):
    """
    This function finds the maximum subgraph common to gbase and gopt. It is
    adapted from a StackOverflow discussion on a heuristic for max common subgraph.

    Input Args:
        gbase: graph consisting of only those clinical nodes occurring in the
        base plan

        gopt: graph consisting of only those clinical nodes occurring in the
        optimal plan

    Output:
        gcommon: max subgraph common to gbase and gopt

    """

    gcommon, gbase_unique, gopt_unique = find_max_common_subgraph_noduplicates(gbase, gopt)

    return gcommon



def find_max_common_subgraph_noduplicates(gbase, gopt):
    """
    This function finds the maximum subgraph common to gbase and gopt. It is
    adapted from a StackOverflow discussion on a heuristic for max common subgraph.

    URL 1: https://stackoverflow.com/questions/14643948/how-can-i-find-maximum-common-subgraph-of-two-graphs
    URL 2: https://stackoverflow.com/questions/43108481/maximum-common-subgraph-in-a-directed-graph

    This function assumes that there are no nodes with "duplicate" labels (they
    can always be distinguished via other information associated with the node).

    Input Args:
        gbase: graph consisting of only those clinical nodes occurring in the
        base plan

        gopt: graph consisting of only those clinical nodes occurring in the
        optimal plan

    Output:
        gcommon: max subgraph common to gbase and gopt

        gbase_unique: subgraph that contains any edges in gbase that are not
        common to gbase and gopt

        gopt_unique: subgraph that contains any edges in gopt that are not
        common to gbase and gopt

    """

    #Initialize as a directed graph.
    gcommon = nwx.DiGraph()
    gbase_unique = nwx.DiGraph()
    gopt_unique = nwx.DiGraph()

    #For each edge in gbase, if gopt also has it then add the edge to gcommon.
    #if gopt does not have the edge then add it to gbase_unique.
    for e in list(gbase.edges):
        u = e[0]
        v = e[1]
        if gopt.has_edge(u, v):
            print('Has')
            print(u, v)
            gcommon.add_edge(u, v)
        else:
            print('Has not')
            print(u, v)
            gbase_unique.add_edge(u, v)

    #For each edge in gopt, if gbase does not have it then add the edge to gopt_unique.
    for e in list(gopt.edges):
        if gbase.has_edge(e[0], e[1]) is False:
            gopt_unique.add_edge(e[0], e[1])


    print('Printing gcommon')
    print(gcommon.edges)
    print(gcommon.nodes)

    print('Printing gbase_unique')
    print(gbase_unique.edges)
    print(gbase_unique.nodes)

    print('Printing gopt_unique')
    print(gopt_unique.edges)
    print(gopt_unique.nodes)

    #Check for nodes common to gbase and gopt that have not been added to gcommon.
    for n in gbase_unique.nodes:
        if n in gopt_unique.nodes:

            #Node n is in both gbase_unique and gopt_unique. This means that there
            #is at least one edge incident to n that is not common to gbase and
            #gopt. However the node n is common to gbase and gopt, and should be
            #added to gcommon if it is not already in gcommon.
            if n not in gcommon.nodes:
                gcommon.add_node(n)

    print('Printing final max common subgraph')
    print(gcommon.edges)
    print(gcommon.nodes)

    return gcommon, gbase_unique, gopt_unique



def find_differences(gbase, gopt, gsame):
    """
    This function deletes gsame from gbase and from gopt to find the differences
    between the two. In graph rewriting terminology, here LHS = gsame, Z = null,
    RHS = null. Note that some code may overlap with find_max_common_subgraph.

    Input Args:
        gbase: graph consisting of only those clinical nodes occurring in the
        base plan

        gopt: graph consisting of only those clinical nodes occurring in the
        optimal plan

        gsame: graph consisting of nodes that are common to gbase and gopt

    Output:
        gbase_diff: graph consisting of only those nodes in gbase that are not
        present in gopt

        gopt_diff: graph consisting of only those nodes in gopt that are not
        present in gbase

    """


    #Keeping graph structure of differences helps to know in what order the
    #differing clinical nodes occur.
    gbase_diff = nwx.DiGraph(gbase)
    gopt_diff = nwx.DiGraph(gopt)
    gsame_copy = nwx.DiGraph(gsame)

    #Remove the common edge present in gbase and gopt from each graph.
    for e in list(gsame.edges):
        u = e[0]
        v = e[1]
        gbase_diff.remove_edge(u, v)
        gopt_diff.remove_edge(u, v)

    #Remove the corresponding vertices of the above edge.
    for e in list(gsame.edges):
        u = e[0]
        v = e[1]

        gbase_diff.remove_node(u)
        gbase_diff.remove_node(v)
        gopt_diff.remove_node(u)
        gopt_diff.remove_node(v)
        gsame_copy.remove_node(u)
        gsame_copy.remove_node(v)

    #Remove any additional vertices in common that have not already been removed.
    for n in gsame_copy.nodes:
        gbase_diff.remove_node(n)
        gopt_diff.remove_node(n)


    print('Printing gbase diffs:')
    print(gbase_diff.nodes)
    print(gbase_diff.edges)
    print('Printing gopt diffs:')
    print(gopt_diff.nodes)
    print(gopt_diff.edges)

    return gbase_diff, gopt_diff



    ############################################################################

    def find_max_common_subgraph_duplicates(gbase, gopt):
        """
        This function finds the maximum subgraph common to gbase and gopt, and
        considers the case where there may be nodes with "duplicate" labels.

        TODO: test this function with examples.

        Input Args:
            gbase: graph consisting of only those clinical nodes occurring in the
            base plan

            gopt: graph consisting of only those clinical nodes occurring in the
            optimal plan

        Output:
            gcommon: max subgraph common to gbase and gopt

        """

        gcommon, gbase_unique, gopt_unique = find_max_common_subgraph_noduplicates(gbase, gopt)

        #Check for node n common to gbase and gopt. If no edge incident to n has
        #been added to gcommon, but n is already in gcommon then this may be a new
        #duplicate node occurring elsewhere in the graphs. If so, it must be added
        #to gcommon.
        for n in gbase_unique.nodes:
            in_gcommon = False
            if n in gopt_unique.nodes:

                if n in gcommon.nodes:
                    #Check adjacency to see if any edge incident to n has been
                    #added to gcommon already.
                    print('Checking adjacency...')
                    print(n)

                    for m in gbase.in_edges(n):
                        print(m)
                        if gcommon.has_edge(m[0], n):
                            in_gcommon = True
                            break
                    if in_gcommon is True:
                        continue

                    for m in gbase.out_edges(n):
                        print(m)
                        if gcommon.has_edge(n, m[1]):
                            in_gcommon = True
                            break
                    if in_gcommon is True:
                        continue

                    for m in gopt.in_edges(n):
                        print(m)
                        if gcommon.has_edge(m[0], n):
                            in_gcommon = True
                            break
                    if in_gcommon is True:
                        continue

                    for m in gopt.out_edges(n):
                        print(m)
                        if gcommon.has_edge(n, m[1]):
                            in_gcommon = True
                            break
                    if in_gcommon is True:
                        continue
                    else:
                        #Adding a duplicate node that has no edges incident to it
                        #that are common to both gbase and gopt.
                        gcommon.add_node(n)


        print('Printing final max common subgraph')
        print(gcommon.edges)
        print(gcommon.nodes)

        return gcommon
